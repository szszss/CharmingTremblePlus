旧的字体渲染器的原理是用FreeType获取字符串中每个字符的位图,然后逐一烘焙到纹理上,最后把纹理渲染到屏幕上. 毫无疑问烘焙一个文字纹理是个消耗资源的事情,因此旧字体渲染器有两种渲染函数:静态字符串渲染和易变字符串渲染.
两种渲染函数都会对文字纹理进行缓存,但缓存策略都不相同,由于旧字体渲染器已经取消了,因此这里就不过多讨论...
新字体渲染器直接在每轮渲染时逐字符渲染,因此没有了缓存机制,也就不再区分静态和易变字符串.
实现原理:
1.游戏内部统一使用Unicode编码的多字节字符串(wstring,或wchar_t*),假如你读过旧程序的说明的话,就会知道旧程序在内部使用2种编码...显然现在比过去高明了许多.
2.不同的编译器的wchar_t的长度不同(MSVC是双字节,GCC是四字节),因此不同环境下使用的编码也有所不同,双字节环境下使用UCS2(65535个潜在可用字符),四字节环境下使用UTF-32(大约一百万个...),尽管实际上并非全都用到...但这里我们暂且不管,就先视为全部都可能用到.由于.
3.我们把65535/一百万个字符分为256/4351个片段,即每个片段存储256个字符.
4.每当我们需要渲染一个字符时,就先寻找这个字符所在的片段,伪代码如下:
	片段 chars[256]; //或4351
	...
	wchar_t c = xxx;
	片段 p = chars[c>>8];
5.找到片段后,判断这个片段是否已经被烘培到文字纹理上,如果没有的话,就把这整个片段烘培到一个新纹理上;有的话,则直接获取纹理.
6.根据字符的低8位来查找它在纹理上的位置,然后将对应区域渲染到屏幕上. 
基本实现就是这样...